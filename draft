04/02/2026

Most basic version done. Got keyboard hooks set up, mouse hooks set up. Got pointer motion movement.

However, I never really did real isometric graphics. It is MANDATORY in the subject to have an isometric view.

Isometric is 120 degrees between all lines.

I should try to get that, and then implement rotation/zoom (with pointer motion rotation).

Missions for now:
- Rewrite/restructure code to be clearer
	- More sub-structures
	- Better variable names
	- Normed comments (before typedef or function)
	- Use AI to suggest better names - I can improve a lot there



07/02/2026

Code has been refactored. Except draw, because draw is the last hurdle.

It is not *perfect*. It's good enough, however. Next projects will be better, learn as you go, yadda yadda.

God struct now has tons of smaller sub-structs. Init and exit functions benefit hugely from this, they are extremely readable.

Map building is not extremely readable, but it's not bad at all. Will do better next time.

Hooks are very readable. Hook key_repeat is not ideal, has a lot of stuff in there including executing keybind actions. Not the best place. But not bad.

Engine loop was insanely improved. It's very clean.

The last hurdle is draw. Drawing functions were simplified a tiny bit, but are still very complex. After draw is fixed though, the project is complete.

Listing steps to project completion:
- Fix draw.c
	- Understand bresenham drawing algorithm fully
	- Fix translation (add x_offset and y_offset AFTER 3D translation)
	- Add zoom (multiply values by zoom before/after translation but before adding offsets)
	- Fix rotation (add 2 modifiers to 3D translation instead of just 1, to rotate 3D at a up/down angle and left/right)
	- Implement RMB rotation (easy)
	- Understand 3D translation algorithm fully
	- Add colors in (send colors to bresenham algorithm, calculate gradient based on where we are in the loop)
	- Make code concise, organized and readable, of course
	- (ADDED 09/02) Remove conditionals in hot loop

Extra stuff I'm not going to do:
- Overlay for rendering info
- (ADDED 09/02) No outside-of-screen calculations (unless it turns out to be really simple once I think about it?)



09/02/2026

Trying to refactor draw and add colors.

The two line draw functions were simplified and commented, I understand bresenham now. Colors were added, but look a bit weird because I'm doing simple arithmetic. Working on a better color gradient.

Steps done:
- Understand bresenham

Steps WIP:
- Add colors
- Make code concise

New steps to add:
- Remove conditionals in hot loop, remove pixel_put returning a value.
	- Turns out this is useless and hurts more than anything. Also makes code less readable.
	- Care: cannot remove window boundary conditional because I am drawing lines outside of screen. This is way more complicated than it seems, might work on it.
- Add -O3 to Makefile
	- Should speed up program by 1.5x-2x-3x





10/02/2026

Colors added. Hot loop conditionals removed, img_state removed (now only a bool). Made draw sync with fps (really dumb that it wasn't the case!). Added -O3.

Still boundary conditionals in pixel_put as I am rendering stuff outside of screen (dumb, but to be fixed later).

Summary of TODOs:
- Fix draw.c
	- Fix translation: ez
	- Fix zoom: ez
	- Fix rotation: reading to do
	- Implement RMB rotation: ez once rotation is done, but hard to get good controls in 3D with only 2 axes
	- Build understanding of sin/cos 3D rotation math: reading and thinking to do
	- Improve draw.c code, still: ez




11/02/2026

draw.c refactoring draft:
- The 2 line drawing functions are optimized and normed
- The function to choose which drawing function to use and compose points and colors into the arguments is too long
	- Fixed
- I have a transform function to make points into 3D which I think is probably bad
	- WIP now
- The function to link points together and decide their x/y is too big and very badly designed
	- Fixed
- Draw image function is ok (could eventually grow)
	- Ok for now


- Translate is fixed
- Zoom is "fixed" (more on this)
- Rotate is WIP right now

- Zoom issues:
	- Due to the way I'm drawing, my zoom by default zooms to point 0,0 of my wireframe model, not pixel 0,0 of the screen.
	- Zooming works, but is not centered at the middle of the screen (and no easy way to center it to the cursor's screen position).
	- Fixing this takes more than a clever formula, it takes rethinking the way that I draw my model. Don't need to modify absolutely everything, but just need to rethink it at a base level and touch a few values here and there.
	- Right now, this is one of the last hurdles that I'm bundling with (2) hiding stuff behind terrain and (3) not processing points/lines outside of the screen. Basically I'll work on it once everything else is squeaky clean. Or just turn in and say fuck it.

- Rotate:
	- Works, but the stupid isometric transformation kind of ruins the way my thing rotates. Maybe unavoidable. Might be fine. Will test more.
- One extra thing
	- Gonna code "R" or MMB to reset states back to their default

Summary of stuff that's done:
- Fixing translate (was ez)
- Fixing zoom (ez)
- Fixing rotation (not perfect, can nitpick)
- RMB rotation (ez)



Big summary:
This is starting to get good, but:
0. Clean up code, but this comes at the end. Code is already 90% clean anyway, but draw.c still needs more cleaning.
1. Every transformation is centered at 0,0 of the wireframe model. Would be better if:
	- Rotation was centered at the center of the model
	- Zoom was centered either at the center of the screen, or where the mouse is
2. The figure doesn't start out properly centered & de-zoomed
	- Need to get a good picture from the start instead of having to play with controls to center the model
3. I'm still not 100% on the orthographic projection and what angles to start with to simulate an isometric view
	- Maybe remove POINT_DISTANCE nonsense to start with (just need to control zoom)
4. Controls, keyboard is too slow, mouse is ok
	- Just speed up keyboard controls
	- Add keybinds: R (or MMB) to reset to default view
		- 1 2 3 to switch between 3 orthographic POVs
5. Extra stuff
	- Again, calculating stuff that's outside the screen
	- And hiding some stuff behind the terrain
	- Eventually, adding some sort of perspective
	- Eventually eventually, just redoing this entire piece of shit but way better

PS:
The more I spend time on this the more I realize how much better I could've made it. Typical. It should be possible to code something right away that will work for full 3D (parsing .obj blender files or whatever) and adapt it to FdF files.
At this point though, 2 things:
1. This project isn't as crazy interesting to me as fractol or some others. I just didn't have THAT much fun with it.
2. I'm already late on my projects. Philosophers and Minishell await
Verdict:
Get it clean, but don't do extra stuff. Keep the ideas somewhere just in case, but close the case and move on.
Points 0, 1, 2, 3, 4 remain. Once that's done, buh-bye.



13/02/2026

WIP now:

DONE:
- Added keybinds 1, 2, 3, 4 to switch views (isometric, ortho 1, 2, 3)
	- These don't really work yet but only because I need to fix projection
- Controls are fixed, mouse and keyboard both feel fine, except when it starts lagging
	- Lag is caused by me stupidly doing out-of-screen calculations, to be fixed
- Zoom and rotate now zoom and rotate based on the center of the model (this is fucked btw if the model starts with a super long or short line compared to the rest)
	- Won't fix the problem with 1st line, fuck it at this point
- Isometric/orthographic projection is done and clean
	- POINT_DISTANCE is necessary or the distance between points gets to be so small it's either 0 or 1
	- There should be a better fix for this but I'm just over with this project at this point
- Height_mod can easily overflow, but this is a bit whatever
	- Doesn't really matter - it's not the cleanest, but not a problem
- Code cleaned up - no norm errors

In other words, points 1, 3 and 4 are done. 2 remains, then we're done (almost).
Note: I can't leave this the way it is, I HAVE to find a solution to stop calculating stuff that's outside the screen. Models turn into a laggy mess very fast when zooming in too much.

2. Fixing default position on screen
- Get the x distance that model takes (without zoom)
get x y of last theoretical point (if model is rectangular)
x will be widths[0], y will be height
calculate where its screen x, y are with all transforms
formula should be simpler than all 3 transforms, we ignore z, just want x and y without z
actually we just want x
- Get the y distance
point at 0, widths[0] is at the top, get its y value
point at height, widths[0] is at the bottom, get its y value
subtract both, we got y delta

x and y deltas tell us how big the model is
we want to make em both small enough that neither of them is bigger than 80% of win_x or win_y
that's for zoom

now for x_offset and y_offset
knowing zoom and model width/height, we want to center model
x_offset should be (win_x - model_actual_width_with_zoom) / 2
y_offset should be (win_y - model_actual_height_with_zoom) / 2

easy enough, lets go



1.
x depends on y so I need to know both
as I said, x is widths[0] and y is height
need to transform those into a final X using the formulas we got
X = widths[0] * POINT_DISTANCE * cos(y) * cos(z) - height * POINT_DISTANCE * sin(z)
this should be the formula for our final X
zoom = (WIN_X * 0.8) / X

2.
y depends on x also
a. x is widths[0] and y is 0
b. x is widths[0] and y is height
b - a gives final Y
point->y = x * cos(y) * sin(z) + y * cos(x) * cos(z)
Y = height * cos(x) * cos(z)
Should be the simplified equation
zoom = (WIN_Y * 0.8) / Y

We have 2 zoom values. The smaller one wins. Use that one, set it for zoom.





END SPRINT:

Working on:
1. Centering

Had a problem. Let's take this slower.

x3 = (y * sin(x) * sin(y) + x * cos(y)) * cos(z) - y * cos(x) * sin(z)

Now for y

y3 = (y * sin(x) * sin(y) + x * cos(y)) * sin(z) + y * cos(x) * cos(z)




























2. Not processing points outside of screen (got a strategy for it)
	- If p1.x and p2.x < 0 or p1.x and p2.x >= WIN_X or p1.y and p1.y < 0 or p1.y and p2.y >= WIN_Y, skip
	- This saves some lag but not all of it (in case of stupid height values)
	- I added a condition to bresenham draw to try and avoid lag with stupid height, but it only works if the line starts drawing from the pixel inside of the screen.
		- The only option to fix this is to draw lines on all 8 octants, and start from wherever, but always start from the point that's closest to the center of the screen
		- Note that this isn't 100% foolproof, if you try to draw from a pixel that's very far to a pixel that's very far, well, fuck you.
			- Not gonna try to improve this for now, fuuuuuuuck it.









