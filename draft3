Features to implement (along with base program):
- Left click + dragging moves the view around
- Right click + dragging rotates the view around
- Mousewheel up/down changes the height (or depth when negative)
- A GUI that displays when pressing 'h'
	- GUI uses xpm file for a pretty little box visual
	- Box has some useful info about the drawing (not sure yet)
	 	- File name?
		- Current heigh modifier
		- Current zoom modifier
		- Current color palette?
		- State of hiding mesh which is behind other stuff (on/off)
		- FPS?
	- Box also has keybind info
- Keybind to enable/disable (should be on by default) hiding mesh that's behind other stuff
- Keybind to enable/disable default coloring


Steps to implement all this:
- Read map, store it somewhere
- Use map to display small circles at first on every point that needs to be linked
	- Need formula to draw a circle with a certain radius centered on a certain coord
	- Can be a simple diamond btw, this isn't necessary, just to get a basic view of things
- Figure out formula to view said points at an angle
	- See how changing values in that formula changes the angle and does a "rotating" effect
	- Start binding keys to change values in real time and figure out a way to do all this without lag
- Should have movement in all directions for next step
	- Next step is to manage to make pointer-controlled rotation and displacing
	- If this isn't possible for whatever reason, key controls are still ok
	- Can still have key controls with mouse, for completeness
	- WASD moves view around, arrows rotate (or sth)
- Try making a little GUI image with info that displays with h
	- This is gonna be complicated because the only mlx function to display strings writes TO THE WINDOW directly, it doesn't allow writing to an image
	- Yes this is dumb and yes the mlx is [censored]
	- Pretty visuals with an xpm file, just for fun
	- Enable dragging this window around

Progress:
- Writing map filling function
- This also checks map, ofc
- Running into a problem:
	Map format is not fully decided yet.
	-?\d+(,0x[0-9a-f]{1,6})?
	Meaning: an optional -, one or more digits, and an optional comma, then 0, then x, then between 1 and 8 digits or a, b, c, d, e, f
	Two problems:
	1. This does not test if the digits fit within an int. What do we do? We can either very annoyingly test for an int value, or we can just say whatever and let ints overflow.
	What I mean by very annoyingly, it's not so annoying. It's just that I have to make a libft func for it and since it will run during map-filling, it will only detect this error quite late. Doable.
	2. It's kinda annoying for the color because 0x0 is a color. 0xff is a color (blue). Shit, 255 is a color (blue again). So how about 0,255?
	I mean, it's really up to me, right? I can say, "oh, you can only specify color with 0xrrggbb and cannot ommit anything even if they are all 0"
	I can also say "oh well actually if you'd like to just write 0x0, or 0xf, or 0xff, or 0xffff, or 0xff00, etc... you can)
	And I can also say "actually 0 is fine too"
	And I can even say "actually 255 or 2026036 is fine too"
	What's the point though? 0xrrggbb is fine and explicit. 0x000000 may be annoying to type but at least it looks exactly like what a color code would be.
	All that matters in the end is how the maps are formatted, right?
	Ok after a bit of grepping with RegExp, it would appear we have 0xff, 0xff00, and 0xff0000 for example, but not 0xf, not 0xfff, and no [0-9],(anything else than 0x..)
	This means color HAS to be described as a hexadecimal value starting with 0x, and it can at least be 2 digit, 4 digit or 6 digit. But it would just make sense to allow it to be between 1 and 6 digits.
	Go to work now.

More progress:
- I was thinking about how to store and structure my data
	- 1D or 2D array
	- It seems generally 1D is better, so that's what I'll go for
	- There could also be other ways to store it
	- After thinking about it for quite some time, I figured that my approach was too hasty. I should already be thinking about the display algorithm and I can create fake hardcoded simple maps to test it out easily.
	- HowEVER... since I've already started writing the file-reading code, I'll just finish it, just this once. But for next time, it might be more interesting to just create very rapidly a fake hard-coded map without messing around with opening files and expanding my program's structure. Next time.

More more:
- As stated above, working on input and file-reading
- One thing is that I'm using a lot of atoi atos atoh etc...
	- I can either just code them, or I can just right now, right away code an A to SomethingBase function which will do absolutely everything
	- This theoretical function takes in a char * (the ascii part), a void * (where it should write stuff), a base (that's a char * too), and a size (that's a size_t, likely the return of a sizeof())
	- It does the following:
		- Convert the ascii part (could be written in a base format) into a numerical value, written into the void *, according to a size. The size is there for overflow (it's the amount of bytes available to us in the void * - if the ascii part takes any more space than that, it's overflow - we stop writing and simply return 1)
		- The goal would be having a one-stop-shop for converting ascii into anything. Can even convert into something bigger than intmax_t
